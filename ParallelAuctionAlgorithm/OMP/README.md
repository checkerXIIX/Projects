# OpenMP Parallel Auction Algorithm

## Overview
This implementation parallelizes the **Auction Algorithm** using **OpenMP** with a **Jacobi synchronous approach** to speed up the **bidding and assignment phases**. Parallelism is achieved by distributing the workload across multiple threads.

---

## Parallelization Strategy

### 1. **Bidding Phase (Parallelized)**
- The **Jacobi approach** enables parallel computation of bids across multiple **unassigned resources**.
- OpenMP's `#pragma omp parallel for` directive is used:
  ```cpp
  #pragma omp parallel for reduction(merge: bidders) num_threads(NUM_THREADS)
- Since OpenMP does not natively support a merge reduction, a custom reduction is defined:
  ```cpp
  #pragma omp declare reduction (merge : std::vector<bid> : 
    omp_out.insert(omp_out.end(), omp_in.begin(), omp_in.end()))
- This ensures that bids generated by different threads are correctly merged into the bidders vector.

### 2. **Assignment Phase (Parallelized)**
- After bidding, **all threads synchronize**, and the assignment phase begins.
- The **assignment process** is parallelized using:
  ```cpp
  #pragma omp parallel for num_threads(NUM_THREADS)
- This efficiently distributes task assignments among threads **without additional modifications**.

## Implementation Notes
- The number of threads T can be adjusted dynamically.
- Parallelism is introduced while maintaining correctness using a custom merge reduction.
- The OpenMP approach significantly reduces execution time compared to the serial version.

---

## References
- The Figure provides a detailed breakdown of the parallel logic.